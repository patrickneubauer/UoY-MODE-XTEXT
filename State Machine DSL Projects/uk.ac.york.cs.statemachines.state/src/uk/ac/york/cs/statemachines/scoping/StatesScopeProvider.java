/*
 * generated by Xtext
 */
package uk.ac.york.cs.statemachines.scoping;

import java.util.Collection;
import java.util.HashSet;

import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;

import uk.ac.york.cs.statemachines.State;
import uk.ac.york.cs.statemachines.StateMachine;
import uk.ac.york.cs.statemachines.StatemachinesPackage;
import uk.ac.york.cs.statemachines.Transition;

/**
 * This class contains custom scoping description.
 * 
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class StatesScopeProvider extends org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider {

	public IScope scope_Transition_state(Transition transition, EReference eReference) {
		if (eReference.equals(StatemachinesPackage.Literals.TRANSITION__STATE))
			// return custom scope results for transitions
			return Scopes.scopeFor(getAllowedStates(transition));
		return IScope.NULLSCOPE;
	}

	/**
	 * Compute and return a list of allowed states for a given transition
	 * 
	 * @param transition transition for which the allowed states are computed
	 * @return the list of allowed states for the given transition
	 */
	private Collection<State> getAllowedStates(Transition transition) {
		State sourceState = (State) transition.eContainer();
		StateMachine statemachine = (StateMachine) sourceState.eContainer();
		Collection<State> allowedStates = new HashSet<State>();
		allowedStates.addAll(statemachine.getStates());
		allowedStates.remove(sourceState); // self transitions are not allowed
		return allowedStates;
	}

}
